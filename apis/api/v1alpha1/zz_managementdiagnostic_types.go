/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendRequestDataMaskingHeadersObservation struct {
}

type BackendRequestDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type BackendRequestDataMaskingObservation struct {
}

type BackendRequestDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []BackendRequestDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []BackendRequestDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type BackendRequestDataMaskingQueryParamsObservation struct {
}

type BackendRequestDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type BackendResponseDataMaskingHeadersObservation struct {
}

type BackendResponseDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type BackendResponseDataMaskingQueryParamsObservation struct {
}

type BackendResponseDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ManagementDiagnosticBackendRequestObservation struct {
}

type ManagementDiagnosticBackendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []BackendRequestDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type ManagementDiagnosticBackendResponseDataMaskingObservation struct {
}

type ManagementDiagnosticBackendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []BackendResponseDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []BackendResponseDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type ManagementDiagnosticBackendResponseObservation struct {
}

type ManagementDiagnosticBackendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []ManagementDiagnosticBackendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type ManagementDiagnosticFrontendRequestDataMaskingHeadersObservation struct {
}

type ManagementDiagnosticFrontendRequestDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ManagementDiagnosticFrontendRequestDataMaskingObservation struct {
}

type ManagementDiagnosticFrontendRequestDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []ManagementDiagnosticFrontendRequestDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []ManagementDiagnosticFrontendRequestDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type ManagementDiagnosticFrontendRequestDataMaskingQueryParamsObservation struct {
}

type ManagementDiagnosticFrontendRequestDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ManagementDiagnosticFrontendRequestObservation struct {
}

type ManagementDiagnosticFrontendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []ManagementDiagnosticFrontendRequestDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type ManagementDiagnosticFrontendResponseDataMaskingHeadersObservation struct {
}

type ManagementDiagnosticFrontendResponseDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ManagementDiagnosticFrontendResponseDataMaskingObservation struct {
}

type ManagementDiagnosticFrontendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []ManagementDiagnosticFrontendResponseDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []ManagementDiagnosticFrontendResponseDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type ManagementDiagnosticFrontendResponseDataMaskingQueryParamsObservation struct {
}

type ManagementDiagnosticFrontendResponseDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type ManagementDiagnosticFrontendResponseObservation struct {
}

type ManagementDiagnosticFrontendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []ManagementDiagnosticFrontendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type ManagementDiagnosticObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ManagementDiagnosticParameters struct {

	// +kubebuilder:validation:Required
	APIManagementLoggerID *string `json:"apiManagementLoggerId" tf:"api_management_logger_id,omitempty"`

	// +kubebuilder:validation:Required
	APIManagementName *string `json:"apiManagementName" tf:"api_management_name,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysLogErrors *bool `json:"alwaysLogErrors,omitempty" tf:"always_log_errors,omitempty"`

	// +kubebuilder:validation:Optional
	BackendRequest []ManagementDiagnosticBackendRequestParameters `json:"backendRequest,omitempty" tf:"backend_request,omitempty"`

	// +kubebuilder:validation:Optional
	BackendResponse []ManagementDiagnosticBackendResponseParameters `json:"backendResponse,omitempty" tf:"backend_response,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendRequest []ManagementDiagnosticFrontendRequestParameters `json:"frontendRequest,omitempty" tf:"frontend_request,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendResponse []ManagementDiagnosticFrontendResponseParameters `json:"frontendResponse,omitempty" tf:"frontend_response,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPCorrelationProtocol *string `json:"httpCorrelationProtocol,omitempty" tf:"http_correlation_protocol,omitempty"`

	// +kubebuilder:validation:Required
	Identifier *string `json:"identifier" tf:"identifier,omitempty"`

	// +kubebuilder:validation:Optional
	LogClientIP *bool `json:"logClientIp,omitempty" tf:"log_client_ip,omitempty"`

	// +kubebuilder:validation:Optional
	OperationNameFormat *string `json:"operationNameFormat,omitempty" tf:"operation_name_format,omitempty"`

	// +kubebuilder:validation:Required
	ResourceGroupName *string `json:"resourceGroupName" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	SamplingPercentage *float64 `json:"samplingPercentage,omitempty" tf:"sampling_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Verbosity *string `json:"verbosity,omitempty" tf:"verbosity,omitempty"`
}

// ManagementDiagnosticSpec defines the desired state of ManagementDiagnostic
type ManagementDiagnosticSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ManagementDiagnosticParameters `json:"forProvider"`
}

// ManagementDiagnosticStatus defines the observed state of ManagementDiagnostic.
type ManagementDiagnosticStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ManagementDiagnosticObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ManagementDiagnostic is the Schema for the ManagementDiagnostics API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type ManagementDiagnostic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagementDiagnosticSpec   `json:"spec"`
	Status            ManagementDiagnosticStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ManagementDiagnosticList contains a list of ManagementDiagnostics
type ManagementDiagnosticList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagementDiagnostic `json:"items"`
}

// Repository type metadata.
var (
	ManagementDiagnostic_Kind             = "ManagementDiagnostic"
	ManagementDiagnostic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ManagementDiagnostic_Kind}.String()
	ManagementDiagnostic_KindAPIVersion   = ManagementDiagnostic_Kind + "." + CRDGroupVersion.String()
	ManagementDiagnostic_GroupVersionKind = CRDGroupVersion.WithKind(ManagementDiagnostic_Kind)
)

func init() {
	SchemeBuilder.Register(&ManagementDiagnostic{}, &ManagementDiagnosticList{})
}
