/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationRuleCollectionRuleObservation struct {
}

type ApplicationRuleCollectionRuleParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationAddresses []*string `json:"destinationAddresses,omitempty" tf:"destination_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationFqdnTags []*string `json:"destinationFqdnTags,omitempty" tf:"destination_fqdn_tags,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationFqdns []*string `json:"destinationFqdns,omitempty" tf:"destination_fqdns,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationUrls []*string `json:"destinationUrls,omitempty" tf:"destination_urls,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Protocols []ProtocolsParameters `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// +kubebuilder:validation:Optional
	SourceAddresses []*string `json:"sourceAddresses,omitempty" tf:"source_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIPGroups []*string `json:"sourceIpGroups,omitempty" tf:"source_ip_groups,omitempty"`

	// +kubebuilder:validation:Optional
	TerminateTLS *bool `json:"terminateTls,omitempty" tf:"terminate_tls,omitempty"`

	// +kubebuilder:validation:Optional
	WebCategories []*string `json:"webCategories,omitempty" tf:"web_categories,omitempty"`
}

type PolicyRuleCollectionGroupApplicationRuleCollectionObservation struct {
}

type PolicyRuleCollectionGroupApplicationRuleCollectionParameters struct {

	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Priority *int64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	Rule []ApplicationRuleCollectionRuleParameters `json:"rule" tf:"rule,omitempty"`
}

type PolicyRuleCollectionGroupNatRuleCollectionObservation struct {
}

type PolicyRuleCollectionGroupNatRuleCollectionParameters struct {

	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Priority *int64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	Rule []PolicyRuleCollectionGroupNatRuleCollectionRuleParameters `json:"rule" tf:"rule,omitempty"`
}

type PolicyRuleCollectionGroupNatRuleCollectionRuleObservation struct {
}

type PolicyRuleCollectionGroupNatRuleCollectionRuleParameters struct {

	// +kubebuilder:validation:Optional
	DestinationAddress *string `json:"destinationAddress,omitempty" tf:"destination_address,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationPorts []*string `json:"destinationPorts,omitempty" tf:"destination_ports,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Protocols []*string `json:"protocols" tf:"protocols,omitempty"`

	// +kubebuilder:validation:Optional
	SourceAddresses []*string `json:"sourceAddresses,omitempty" tf:"source_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIPGroups []*string `json:"sourceIpGroups,omitempty" tf:"source_ip_groups,omitempty"`

	// +kubebuilder:validation:Required
	TranslatedAddress *string `json:"translatedAddress" tf:"translated_address,omitempty"`

	// +kubebuilder:validation:Required
	TranslatedPort *int64 `json:"translatedPort" tf:"translated_port,omitempty"`
}

type PolicyRuleCollectionGroupNetworkRuleCollectionObservation struct {
}

type PolicyRuleCollectionGroupNetworkRuleCollectionParameters struct {

	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Priority *int64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	Rule []PolicyRuleCollectionGroupNetworkRuleCollectionRuleParameters `json:"rule" tf:"rule,omitempty"`
}

type PolicyRuleCollectionGroupNetworkRuleCollectionRuleObservation struct {
}

type PolicyRuleCollectionGroupNetworkRuleCollectionRuleParameters struct {

	// +kubebuilder:validation:Optional
	DestinationAddresses []*string `json:"destinationAddresses,omitempty" tf:"destination_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationFqdns []*string `json:"destinationFqdns,omitempty" tf:"destination_fqdns,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationIPGroups []*string `json:"destinationIpGroups,omitempty" tf:"destination_ip_groups,omitempty"`

	// +kubebuilder:validation:Required
	DestinationPorts []*string `json:"destinationPorts" tf:"destination_ports,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Protocols []*string `json:"protocols" tf:"protocols,omitempty"`

	// +kubebuilder:validation:Optional
	SourceAddresses []*string `json:"sourceAddresses,omitempty" tf:"source_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIPGroups []*string `json:"sourceIpGroups,omitempty" tf:"source_ip_groups,omitempty"`
}

type PolicyRuleCollectionGroupObservation struct {
}

type PolicyRuleCollectionGroupParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationRuleCollection []PolicyRuleCollectionGroupApplicationRuleCollectionParameters `json:"applicationRuleCollection,omitempty" tf:"application_rule_collection,omitempty"`

	// +kubebuilder:validation:Required
	FirewallPolicyID *string `json:"firewallPolicyId" tf:"firewall_policy_id,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NatRuleCollection []PolicyRuleCollectionGroupNatRuleCollectionParameters `json:"natRuleCollection,omitempty" tf:"nat_rule_collection,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkRuleCollection []PolicyRuleCollectionGroupNetworkRuleCollectionParameters `json:"networkRuleCollection,omitempty" tf:"network_rule_collection,omitempty"`

	// +kubebuilder:validation:Required
	Priority *int64 `json:"priority" tf:"priority,omitempty"`
}

type ProtocolsObservation struct {
}

type ProtocolsParameters struct {

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// PolicyRuleCollectionGroupSpec defines the desired state of PolicyRuleCollectionGroup
type PolicyRuleCollectionGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PolicyRuleCollectionGroupParameters `json:"forProvider"`
}

// PolicyRuleCollectionGroupStatus defines the observed state of PolicyRuleCollectionGroup.
type PolicyRuleCollectionGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PolicyRuleCollectionGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyRuleCollectionGroup is the Schema for the PolicyRuleCollectionGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type PolicyRuleCollectionGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PolicyRuleCollectionGroupSpec   `json:"spec"`
	Status            PolicyRuleCollectionGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyRuleCollectionGroupList contains a list of PolicyRuleCollectionGroups
type PolicyRuleCollectionGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PolicyRuleCollectionGroup `json:"items"`
}

// Repository type metadata.
var (
	PolicyRuleCollectionGroup_Kind             = "PolicyRuleCollectionGroup"
	PolicyRuleCollectionGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PolicyRuleCollectionGroup_Kind}.String()
	PolicyRuleCollectionGroup_KindAPIVersion   = PolicyRuleCollectionGroup_Kind + "." + CRDGroupVersion.String()
	PolicyRuleCollectionGroup_GroupVersionKind = CRDGroupVersion.WithKind(PolicyRuleCollectionGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&PolicyRuleCollectionGroup{}, &PolicyRuleCollectionGroupList{})
}
