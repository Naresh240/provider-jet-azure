/*
Copyright 2022 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionIncidentObservation struct {
}

type ActionIncidentParameters struct {

	// +kubebuilder:validation:Optional
	Classification *string `json:"classification,omitempty" tf:"classification,omitempty"`

	// +kubebuilder:validation:Optional
	ClassificationComment *string `json:"classificationComment,omitempty" tf:"classification_comment,omitempty"`

	// +kubebuilder:validation:Optional
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	Order *float64 `json:"order" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	OwnerID *string `json:"ownerId,omitempty" tf:"owner_id,omitempty"`

	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ActionPlaybookObservation struct {
}

type ActionPlaybookParameters struct {

	// +kubebuilder:validation:Required
	LogicAppID *string `json:"logicAppId" tf:"logic_app_id,omitempty"`

	// +kubebuilder:validation:Required
	Order *float64 `json:"order" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`
}

type AutomationRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AutomationRuleParameters struct {

	// +kubebuilder:validation:Optional
	ActionIncident []ActionIncidentParameters `json:"actionIncident,omitempty" tf:"action_incident,omitempty"`

	// +kubebuilder:validation:Optional
	ActionPlaybook []ActionPlaybookParameters `json:"actionPlaybook,omitempty" tf:"action_playbook,omitempty"`

	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId" tf:"log_analytics_workspace_id,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Order *float64 `json:"order" tf:"order,omitempty"`
}

type ConditionObservation struct {
}

type ConditionParameters struct {

	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// +kubebuilder:validation:Required
	Property *string `json:"property" tf:"property,omitempty"`

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

// AutomationRuleSpec defines the desired state of AutomationRule
type AutomationRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AutomationRuleParameters `json:"forProvider"`
}

// AutomationRuleStatus defines the observed state of AutomationRule.
type AutomationRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AutomationRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AutomationRule is the Schema for the AutomationRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type AutomationRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AutomationRuleSpec   `json:"spec"`
	Status            AutomationRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AutomationRuleList contains a list of AutomationRules
type AutomationRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AutomationRule `json:"items"`
}

// Repository type metadata.
var (
	AutomationRule_Kind             = "AutomationRule"
	AutomationRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AutomationRule_Kind}.String()
	AutomationRule_KindAPIVersion   = AutomationRule_Kind + "." + CRDGroupVersion.String()
	AutomationRule_GroupVersionKind = CRDGroupVersion.WithKind(AutomationRule_Kind)
)

func init() {
	SchemeBuilder.Register(&AutomationRule{}, &AutomationRuleList{})
}
